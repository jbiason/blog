<!DOCTYPE html>
<html lang="en">
    <head>
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta http-equiv="content-type" content="text/html; charset=utf-8">

      <!-- Enable responsiveness on mobile devices-->
      <!-- viewport-fit=cover is to support iPhone X rounded corners and notch in landscape-->
      <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, viewport-fit=cover">

      <title>Julio Biason .Me 4.3</title>

      <!-- CSS -->
      <link rel="stylesheet" href="https://blog.juliobiason.me/print.css" media="print">
      <link rel="stylesheet" href="https://blog.juliobiason.me/poole.css">
      <link rel="stylesheet" href="https://blog.juliobiason.me/hyde.css">
      <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

      

      
      
    </head>

    <body class=" ">
        
            <div class="sidebar">
                <div class="container sidebar-sticky">
                    <div class="sidebar-about">
                        
                            <a href="https:&#x2F;&#x2F;blog.juliobiason.me"><h1>Julio Biason .Me 4.3</h1></a>
                            
                            <p class="lead">Old school dev living in a 2.0 dev world</p>
                            
                        
                    </div>

                    <ul class="sidebar-nav">
                        
                        
                        <li class="sidebar-nav-item"><a href="&#x2F;">English</a></li>
                        
                        <li class="sidebar-nav-item"><a href="&#x2F;pt">Portugu√™s</a></li>
                        
                        <li class="sidebar-nav-item"><a href="&#x2F;tags">Tags (EN)</a></li>
                        
                        <li class="sidebar-nav-item"><a href="&#x2F;pt&#x2F;tags">Tags (PT)</a></li>
                        
                        
                    </ul>
                </div>
            </div>
        

        <div class="content container">
            
<div class="post">
  <h1 class="post-title">Rust na Vida Real</h1>
  <span class="post-date">
	2022-07-26
	
            <a href="https://blog.juliobiason.me/pt/tags/rust/">#rust</a>
        
  </span>
  <p>J√° faz algum tempo que eu tenho falado sobre Rust, fazendo apresenta√ß√µes, indo
a meetups...</p>
<p>Mas a alguns meses eu tive a oportunidade de finalmente trabalhar num projeto
real em Rust.</p>
<p>Ent√£o, como √© que foi?</p>
<span id="continue-reading"></span><h2 id="cargo-e-magico">Cargo √© m√°gico</h2>
<p>A primeira aplica√ß√£o que eu usei Rust foi uma parte pequena de um grande
projeto. Eu tinha que capturar valores vindos de um websocket e guardar os
mesmos num banco de dados.</p>
<p>Haviam duas op√ß√µes de linguagens que eu poderia usar: Python e C. Python j√°
estava sendo usado em outras partes da empresa, e isso garantiria mais olhos
caso algo desse errado. C estava sendo usado em outra aplica√ß√£o do mesmo
projeto, e eu poderia manter todo o projeto na mesma linguagem. Ambas
linguagens tinham alguns problemas: Eu n√£o tinha certeza que Python conseguiria
lidar com a carga de dados de um stream cont√≠nuo do websocket e eu n√£o queria
ter que escrever meu pr√≥prio processamento de websocket e parser de JSON em C.</p>
<p>E foi por isso que eu usei Rust nesta aplica√ß√£o: Eu tinha a performance de C
com um excelente gerenciador de pacotes, e mais milhares de pacotes
dispon√≠veis.</p>
<p>Assim, Cargo foi quem decidiu o uso de Rust no projeto. E a linguagem se provou
bem capaz, pois a aplica√ß√£o fico rodando at√© o ponto que acabamos esquecendo
que ela estava rodando.</p>
<h2 id="unwrap-e-o-inimigo"><code>.unwrap()</code> √© o inimigo</h2>
<p>Um ponto que eu fa√ßo nas minhas apresenta√ß√µes √© que voc√™ pode usar <code>.unwrap()</code>
(e <code>.expect()</code>) para evitar ter que lidar com erros, e embora o uso deste fa√ßa
com que sua aplica√ß√£o seja encerrada, voc√™ tem total controle sobre <em>onde</em> ela
pode ser encerrada (comparado com um NullPointerException, ou ler valores NULL,
ou n√£o capturar as exce√ß√µes corretas). Mas, no fim das contas, <code>.unwrap()</code> vai
te machucar. Bastante.</p>
<p>Foi o que aconteceu com a segunda aplica√ß√£o que eu escrevi: A parte principal
da aplica√ß√£o era ler um conjunto de bytes, e o significado destes bytes estava
nos bits que os compunham, em uma combina√ß√£o de bitmaps e n√∫meros num formato
tipo UTF-8. Mas n√£o era s√≥ o parsing que estava envolvido: Havia um socket a
ser lido, e os dados parseados tinham que ser guardados num banco de dados, e
haviam os problemas usuais envolvidos nisso -- o socket poderia ser fechado
pelo servidor, n√≥s poder√≠amos perder a conex√£o de rede, o parser poderia
produzir valores estranhos no caso de um bit perdido, que n√£o poderia ser
guardado no banco de dados...</p>
<p>Para cada um dos problemas poss√≠veis (que eram bem claros, j√° que <code>Result</code> √© a
base de quase tudo), e como eu estava com pressa para entregar a aplica√ß√£o, eu
usei um monte de <code>.unwrap()</code>s pelo c√≥digo -- de novo, a ideia era que, se a
aplica√ß√£o crasheasse, pelo menos eu disse que ela podia crashear, e iria me dar
uma mensagem mais ou menos indicando onde. A realidade √© que problemas aconteciam
com tal frequ√™ncia (especialmente o parser recebendo bits estranhos que
produziam valores estranhos) que a aplica√ß√£o n√£o ficava rodando por muito
tempo.</p>
<p>A solu√ß√£o para esses crashes constantes foi bem simples, embora trabalhoso:
trocar todo <code>.unwrap()</code> e <code>.expect()</code> por <code>if let Ok(_)</code> e <code>match</code>. Isso me deu
controle total do que fazer nos casos de valores n√£o esperados. O resultado foi
que a aplica√ß√£o rodou sem problemas por dias, ao ponto que n√≥s, mais uma vez,
esquecemos que ela estava rodando -- exceto quando os dados de entrada mudavam
e n√≥s t√≠nhamos que atualizar nossos filtros.</p>
<h2 id="cargo-de-novo">Cargo de novo</h2>
<p>Nesta segunda aplica√ß√£o, havia um monte de coisinhas chatas no protocolo que
eram realmente complicadas de entender. Felizmente n√≥s conseguimos capturar
alguns pacotes do servi√ßo, que permitiria testar o parser localmente. Tudo que
eu precisava era algo que me desse uma rede de suporte para jogar esses bits e
ver como o c√≥digo processaria.</p>
<p>Com C, isso normalmente significa criar outro execut√°vel para os testes e rodar
esse execut√°vel ao inv√©s do execut√°vel real (e, pra ser honesto, √© exatamente
isso que o Rust faz) mas o Cargo escondeu toda a complexidade de fazer isso. Eu
s√≥ criei <code>test.rs</code> nos meus m√≥dulos, marquei o mesmo com <code>#[cfg(test)]</code>
(indicando que o mesmo s√≥ existe na configura√ß√£o de teste) e <code>cargo test</code>
compilou o c√≥digo e rodou os testes.</p>
<p>O fato que eu tinha um framework de test e um executor de testes logo ali foi
de grande ajuda, especialmente quando um problema era encontrado.</p>
<h2 id="deveria-ter-tentado-tryed-mais">Deveria ter tentado (<code>try</code>ed) mais</h2>
<p>Um dos efeitos colaterais de trocar todo <code>.unwrap()</code> e <code>.expect()</code> for alguma
forma expl√≠cita de tratamento de erro foi o aumento da indenta√ß√£o do c√≥digo --
porque <em>tudo</em> que eu fiz foi fazer essa altera√ß√£o, mas eu n√£o quebrei o c√≥digo
em fun√ß√µes menores.</p>
<p>Rust tem o operador <code>try</code> -- <code>?</code> -- mas isso requer que a fun√ß√£o com o operador
retorne um <code>Result</code>, que eu negligenciei na primeira passagem porque, bom, a
√∫nica sa√≠da das fun√ß√µes era o sucesso e falhas significavam <code>panic!()</code> (por
causa do <code>.unwrap()</code>).</p>
<p>Se eu tivesse usando <code>Result</code> como resultado desde o come√ßo, eu tenho a
impress√£o que o c√≥digo n√£o ficaria uma bagun√ßa com 7-8 n√≠veis de indenta√ß√£o. Ou
seja, outra coisa que eu teria &quot;ganho&quot; se eu n√£o tivesse usado <code>.unwrap()</code>.</p>
<h2 id="async-nao-faz-menor-sentido-ate-que-faz">Async n√£o faz menor sentido at√© que faz</h2>
<p>A terceira aplica√ß√£o no projeto precisava fazer um monte de I/O -- ler de
v√°rios bancos de dados, enviar dados por socket, escrever de volta no banco de
dados... Parecia o perfeito experimento para um projeto async.</p>
<p>Na primeira vers√£o que eu escrevi, eu usei tasks (fun√ß√µes async) da mesma forma
que eu fa√ßo com threads. Isso gerou um monte de erros do borrow checker que eu
n√£o conseguia entender o porqu√™ -- neste ponto, eu j√° conseguia entender
exatamente porque o borrow checker estava reclamando de alguma coisa numa
aplica√ß√£o com threads, mas os erros eram t√£o confusos que eu devo ter
mencionado algo como &quot;async n√£o √© natural em Rust&quot;. E, quando eu finalmente
consegui evitar todas as reclama√ß√µes do borrow checker, a performance foi...
terr√≠vel. Algo como 0.8 registros por segundo, que era extremamente baixo para
o que est√°vamos esperando.</p>
<p>Com essa performance horr√≠vel, eu removi todas as coisas async e usei threads.
Isso estava mais com o que eu estava acostumado -- eu sabia exatamente o que eu
tinha feito de errado quando o borrow checker reclamava de algo -- e a
performance melhorou: O processamento passou a 7 registros por segundo.</p>
<p>Enquanto eu estava nessa reescrita, eu fiquei lendo sobre async e como
funciona, at√© que eu consegui formar um modelo mental para trabalhar desta
forma (mais sobre isso num post futuro). Eu consegui ter algum tempo para
efetivamente aplicar esse modelo mental -- e a√≠ os erros do borrow checker
come√ßaram a fazer sentido, e eu me senti produtivo de novo. O resultado? 70
registros por segundo, uma melhoria de 10x sobre o uso de threads.</p>
<h2 id="conclusao">Conclus√£o</h2>
<p>Tudo isso eu aprendi num espa√ßo de 6 meses. Eu acabei trocando de emprego para
um lugar onde n√£o h√° nada em Rust (por enquanto üòà), e embora a estrada do Rust
seja ingrime e cheia de curvas fechadas, eu ainda acho que vale a pena.</p>
<p>(E, at√© onde eu sei, todas as aplica√ß√µes aqui <em>continuam</em> rodando...)</p>
<!-- 
vim:spelllang=pt:
-->

</div>




        </div>

    </body>

</html>
